import numpy as np
import pandas as pd
from tqdm import tqdm
import matplotlib.pyplot as plt

import Bio
from Bio import AlignIO


def consensus_from_aln(
        alignment: np.array,
) -> np.array:
    """Generate a naive consensus from a fasta alignment

    Args:
        alignment (Bio.Align.MultipleSeqAlignment): alignment

    Returns:
        str: consensus sequence
    """
    consensus = ""
    for i in range(alignment.get_alignment_length()):
        counts = {}
        for record in alignment:
            AA = record.seq[i]
            if AA in counts:
                counts[AA] += 1
            else:
                counts[AA] = 1
        consensus += max(counts, key=counts.get)
    return consensus

def conservation_from_aln(
        alignment: 
) -> np.array:
    """Compute positional conservation from alingment.

    Args:
        alignment (Bio.Align.MultipleSeqAlignment): alignment

    Returns:
        np.array: array of conservation values matching the aligned sequence length
    """

def ungap_alignment(alignment, gap_threshold=0.5):
    """
    Remove gapped positions from a multiple sequence alignment.
    
    Parameters:
        alignment (dict): A dictionary of {id: sequence} for the alignment.
        gap_threshold (float): Proportion of gaps to consider a column mostly gaps (default 0.5).
        
    Returns:
        dict: A dictionary of {id: ungapped_sequence}.
    """
    # Convert alignment to a list of sequences
    sequences = list(alignment.values())
    sequence_ids = list(alignment.keys())
    
    # Transpose alignment to work on columns
    columns = list(zip(*sequences))
    
    # Identify columns to keep (those with gaps below the threshold)
    keep_columns = [
        i for i, column in enumerate(columns) 
        if column.count('-') / len(column) <= gap_threshold
    ]
    
    # Filter sequences to retain only the columns to keep
    ungapped_sequences = {
        seq_id: ''.join(seq[i] for i in keep_columns)
        for seq_id, seq in alignment.items()
    }
    
    return ungapped_sequences


def alignment_to_pssm(alignment):
    """Generate a position-specific scoring matrix from a protein alignment

    Args:
        alignment (Bio.Align.MultipleSeqAlignment): alignment

    Returns:
        pd.DataFrame: position-specific scoring matrix
    """
    pssm = {}
    for i in range(alignment.get_alignment_length()):
        counts = {}
        for record in alignment:
            AA = record.seq[i]
            if AA in counts:
                counts[AA] += 1
            else:
                counts[AA] = 1
        for AA in ["A", "R", "N", "D", "C", "Q", "E", "G", "H", "I", "L", "K", "M", "F", "P", "S", "T", "W", "Y", "V", "-"]:
            if AA not in counts:
                counts[AA] = 0
        pssm[i] = counts
    return pd.DataFrame(pssm).T

## UPDATE: complete this function
def positional_alignment_frequency(position, AA_id, pssm):
    """Get the alignment frequency of amino acid AA_id at a defined position.

    Args:
        position: int, sequence position in reference alignment
        AA_id: str, single-letter amino acid id for query
        pssm: pd.DataFrame: dataframe generated by alignment_to_pssm with
                            single amino acid as index and positions as columns
    
    Returns:
        float: alignment frequency of query AA_id at query position
    """

    return

## UPDATE: this should take a pssm and return a plot of the logo
def plot_sequence_logo(seq_dict, title="Sequence Logo"):
    """
    Plot a sequence logo from a dictionary of sequences.
    
    Parameters:
        seq_dict (dict): A dictionary of {seq_id: sequence}.
        title (str): Title for the sequence logo plot.
    """
    # Convert the dictionary values (sequences) to a list
    sequences = list(seq_dict.values())
    
    # Get the length of the sequences
    seq_length = len(sequences[0])
    
    # Ensure all sequences are the same length
    if not all(len(seq) == seq_length for seq in sequences):
        raise ValueError("All sequences must have the same length.")
    
    # Define the characters (amino acids, nucleotides, or others)
    unique_chars = set("".join(sequences))
    
    # Count occurrences of each character at each position
    counts_df = pd.DataFrame(0, index=sorted(unique_chars), columns=range(seq_length))
    for sequence in sequences:
        for i, char in enumerate(sequence):
            counts_df.at[char, i] += 1
    
    # Convert counts to probabilities
    probabilities_df = counts_df.div(counts_df.sum(axis=0), axis=1).fillna(0)
    
    # Plot an imshow-style heatmap
    plt.figure(figsize=(10, 6))
    sns.heatmap(probabilities_df, cmap="viridis", cbar=False)
    plt.title(title)
    plt.xlabel("Position")
    plt.ylabel("Frequency")

    # add conensus sequence over the heatmap
    for i in range(seq_length):
        consensus = probabilities_df[i].idxmax()
        plt.text(i + 0.5, 1, consensus, transform=plt.gca().transData,
                 horizontalalignment='center', verticalalignment='center',
                 fontsize=12, color='white')
    plt.show()

    # return the probabilities dataframe
    return probabilities_df

## UPDATE: needs to be updated using the notebook that Frances sent
def build_potts_model(
        msa: Bio.al, 
        pseudocount:  | 1e-3
) -> np.array:
    """
    Build a naive Potts model from a multiple sequence alignment (MSA).
    Args:
        msa: list of strings, each string is a protein sequence of equal length.
    Returns:
      h   : single-site fields, shape (L, q)
      J   : pairwise couplings, shape (L, L, q, q)
    """

    # Map characters to integers
    chars = sorted(list(set("".join(msa))))
    c2i = {c: i for i, c in enumerate(chars)}
    N, L = len(msa), len(msa[0])
    q = len(chars)

    # Single frequencies
    fi = np.zeros((L, q))
    for seq in tqdm(msa, desc="Calculating single frequencies"):
        for i, c in enumerate(seq):
            fi[i, c2i[c]] += 1
    fi = (fi + pseudocount) / (N + q * pseudocount)

    # Pair frequencies
    fij = np.zeros((L, L, q, q))
    for seq in tqdm(msa, desc="Calculating pair frequencies"):
        for i in range(L):
            for j in range(i+1, L):
                ai, aj = c2i[seq[i]], c2i[seq[j]]
                fij[i,j,ai,aj] += 1
                fij[j,i,aj,ai] += 1
    fij = (fij + pseudocount) / (N + q * q * pseudocount)

    # Fields and couplings (naive approximation)
    h = -np.log(fi + 1e-12)
    J = np.zeros_like(fij)
    for i in tqdm(range(L), desc="Calculating fields and couplings"):
        for j in range(i+1, L):
            for a in range(q):
                for b in range(q):
                    if fi[i,a] > 0 and fi[j,b] > 0 and fij[i,j,a,b] > 0:
                        J[i,j,a,b] = -np.log(fij[i,j,a,b] / (fi[i,a]*fi[j,b]))
                        J[j,i,b,a] = J[i,j,a,b]
    return h, J